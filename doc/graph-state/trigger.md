# [graphql-state](https://github.com/babyfish-ct/graphql-state)/[Documentation](../README.md)/[Graph state](./README.md)/Trigger

The built-in cache database supports triggers and supports the following two types of events
- EntityChangeEvent: Data is changed
- EntityEvictEvent: Data is evicted form local cache

## 1. EntityChangeEvent

"EntityChangeEvent" represents the event that the entity object is modified

### 1.1. Event type definition

1. Definition of general events for any object type
  ```ts
  export interface EntityChangeEvent {
      readonly eventType: "change";
      readonly typeName: string;
      readonly id: any;
      readonly changedType: "insert" | "update" | "delete";
      readonly changedKeys: ReadonlyArray<EntityKey>;
      has(changedKey: EntityKey): boolean;
      oldValue(changedKey: EntityKey): any;
      newValue(changedKey: EntityKey): any;
  }

  export type EntityKey = string | {
      readonly name: string,
      readonly variables: any
  };
  ```
  
  - eventType: always be "change", used to distinguish between "EntityChangeEvent" and "EntityEvictEvent"
  - typeName: The type of the object that triggered the event. If the object has an inheritance relationship, take the name of the actual type at runtime
  - id: the id of the object
  - changedType: three choices
    - "insert": Indicates that the object is inserted into the cache. At this time, the "newValue" function can be called, but "oldValue" will throw an exception
    - "update": Indicates that the object in the cache has been updated. At this time, both "oldValue" and "newValue" functions can be called
    -"delete": Indicates that the object in the cache is deleted. At this time, the "oldValue" function can be called, but "newValue" will throw an exception
  - has: Determine whether a field has been changed, only the changed field can be used as the parameter of the "oldValue" and "newValue" functions, otherwise it will cause an exception
    Parameters:
    - changedKey: field, divided into two cases
      - Unparameterized field: just a string
      - Parameterized field: pass an object with 2 fields
        - name: the name of the field
        - variables: the variables of the field
  - oldValue: Get the old value of a field before it is modified. If changedType is "insert" or the same parameter will cause the "has" function to return false, an exception will be raised
    Parameters:
    - changedKey: field, divided into two cases
      - Unparameterized field: just a string
      - Parameterized field: pass an object with 2 fields
        - name: the name of the field
        - variables: the variables of the field
  - newValue: Get the new value of a field after it is modified. If the changedType is "delete" or the same parameter will cause the "has" function to return false, an exception will be raised
    Parameters:
    - changedKey: field, divided into two cases
      - Unparameterized field: just a string
      - Parameterized field: pass an object with 2 fields
        - name: the name of the field
        - variables: the variables of the field
       
2. Specific event definitions for specific object types (generated by the code generator, here with [example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts](https://github.com/babyfish-ct/graphql-state/blob/master/example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts) as an example)

  ```ts
  import {ImplementationType} from '../CommonTypes';
  import {BookArgs, BookFlatType} from '../fetchers/BookFetcher';

  export interface BookChangeEvent {

      readonly eventType: "change";

      readonly typeName: ImplementationType<"Book">;

      readonly id: string;

      readonly changedType: "insert" | "update" | "delete";

      readonly changedKeys: ReadonlyArray<BookEntityKey<any>>;

      has(changedKey: BookEntityKey<any>): boolean;

      oldValue<TFieldName extends BookEntityFields>(
          key: BookEntityKey<TFieldName>
      ): BookFlatType[TFieldName] | undefined;

      newValue<TFieldName extends BookEntityFields>(
          key: BookEntityKey<TFieldName>
      ): BookFlatType[TFieldName] | undefined;
  }

  export type BookEntityKey<TFieldName extends BookEntityFields> = 
      TFieldName extends "authors" ? 
      { readonly name: "authors"; readonly variables: BookArgs } : 
      TFieldName
  ;

  export type BookEntityFields = 
      "name" | 
      "store" | 
      "authors"
  ;
  ```
It has the same function as the EntityChangeEvent type, except that the internal field type is more precise. There is no difference in the meaning of its fields, so I wonâ€™t repeat them here.

### 1.2 Add EntityChangeEvent

1. Based on common event types

```ts
import { FC, memo } from 'react';
import { EntityChangeEvent } from 'graphql-state';
import { useTypedStateManager } from './__generated';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const listener = (e: EntityChangeEvent) => {
            if (e.typeName === "BookStore") {
                // TODO
            } else if (e.typeName === "Book") {
                // TODO
            } else if (e.typeName === "Author") {
                // TODO:
            }
        };
        stateManager.addEntityChangeListener(listener);
        return () => {
            stateManager.removeEntityChangeListener(listener);
        }
    }, [stateManager]);
    
    return ...;
});
```

2. Based on dedicated event type

```ts
import { FC, memo } from 'react';
import { useTypedStateManager } from './__generated';
import { BookStoreChangeEvent, BookChangeEvent, AuthorChangeEvent } from './__generated/triggers';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const listeners = {
            "BookStore": (e: BookStoreChangeEvent) => {
                // TODO
            },
            "Book": (e: BookChangeEvent) => {
                // TODO
            },
            "Author": (e: AuthorChangeEvent) => {
                // TODO
            }
        };
        stateManager.addEntityChangeListeners(listeners);
        return () => {
            stateManager.removeEntityChangeListeners(listeners);
        }
    }, [stateManager]);
    
    return ...;
});
```

## 2. EntityEvictEvent

"EntityChangeEvent" indicates that the entity object is evicted from the cache

> Note
>
> 1. Data being evicted from the cache and data being deleted are two completely different concepts
> 2. For application developers, "EntityEvictEvent" is not as useful as "EntityChangeEvent". If you are not interested, you can skip this chapter and look directly at "Examples of practical applications"

### 2.1 Event type definition

1. Definition of general events for any object type
  ```ts
  export interface EntityEvictEvent {
      readonly eventType: "evict";
      readonly typeName: string;
      readonly id: any;
      readonly causedByGC: boolean;
      readonly evictedType: "row" | "fields";
      readonly evictedKeys: ReadonlyArray<EntityKey>;
      has(evictedKey: EntityKey): boolean;
      evictedValue(evictedKey: EntityKey): any;
  }

  export type EntityKey = string | {
      readonly name: string,
      readonly variables: any
  };
  ```
  - eventType: always be "evict", used to distinguish between "EntityEvictEvent" and "EntityChangeEvent"
  - typeName: The type of the object that triggered the event. If the object has an inheritance relationship, take the name of the actual type at runtime
  - id: the id of the object
  - **causedByGC**: Whether triggered by garbage collection
    - true: The current event is caused by garbage collection
    - false: The current event is caused by mutation
    > Note
    >
    > causedByGC is true means indicate that garbage collection caused current event. Only the data discarded by all queries will be garbage collected, so the current event will not cause any queries to be automatically refreshed
  - id: the id of the object
  - evictType: Tow choices
    - "row": Indicates that the entire object is evicted from the cache
    - "fields": Indicates that some fields of the object are evicted from the cache
  - "has": Determine that a field is evicted from the cache, only the evicted field can be used as the parameter of the "evictedValue" function, otherwise it will cause an exception
    Parameters:
    - evictedKey: field, divided into two cases
      -Unparmeterized field: just a string
      -Parameterized field: pass an object with 2 fields
        -name: the name of the field
        -variables: the variables of the field
  -evictedValue: Get the old value of a field before it is evicted from the cache. If the same parameter will cause the "has" function to return false, an exception will be raised
    Parameters:
    - evictedKey: field, divided into two cases
      -Unparmeterized field: just a string
      -Parameterized field: pass an object with 2 fields
        -name: the name of the field
        -variables: the variables of the field

2. Specific event definitions for specific object types (generated by the code generator, here with [example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts](https://github.com/babyfish-ct/graphql-state/blob/master/example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts) as an example)

  ```ts
  import {ImplementationType} from '../CommonTypes';
  import {BookArgs, BookFlatType} from '../fetchers/BookFetcher';


  export interface BookEvictEvent {

      readonly eventType: "evict";

      readonly typeName: ImplementationType<"Book">;

      readonly id: string;

      readonly causedByGC: boolean;

      readonly evictedType: "row" | "fields";

      readonly evictedKeys: ReadonlyArray<BookEntityKey<any>>;

      has(evictedKey: BookEntityKey<any>): boolean;

      evictedValue<TFieldName extends BookEntityFields>(
          key: BookEntityKey<TFieldName>
      ): BookFlatType[TFieldName] | undefined;
  }

  export type BookEntityKey<TFieldName extends BookEntityFields> = 
      TFieldName extends "authors" ? 
      { readonly name: "authors"; readonly variables: BookArgs } : 
      TFieldName
  ;

  export type BookEntityFields = 
      "name" | 
      "store" | 
      "authors"
  ;
  ```
It has the same function as the EntityEvictEvent type, except that the type of this type is more precise. There is no difference in the meaning of its fields, so I wonâ€™t repeat them here.

### 2.2 Add EntityEvictEvent

1. Based on common event types

```ts
import { FC, memo } from 'react';
import { EntityEvictEvent } from 'graphql-state';
import { useTypedStateManager } from './__generated';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const onEvict = (e: EntityEvictEvent) => {
            if (e.typeName === "BookStore") {
                // TODO
            } else if (e.typeName === "Book") {
                // TODO
            } else if (e.typeName === "Author") {
                // TODO:
            }
        };
        stateManager.addEntityEvictListener(onChange);
        return () => {
            stateManager.removeEntityEvictListener(onChange);
        }
    }, [stateManager]);
    
    return ...;
});
```

2. Based on dedicated event type

```ts
import { FC, memo } from 'react';
import { useTypedStateManager } from './__generated';
import { BookStoreEvictEvent, BookEvictEvent, AuthorEvictEvent } from './__generated/triggers';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const listeners = {
            "BookStore": (e: BookStoreEvictEvent) => {
                // TODO
            },
            "Book": (e: BookEvictEvent) => {
                // TODO
            },
            "Author": (e: AuthorEvictEvent) => {
                // TODO
            }
        };
        stateManager.addEntityEvictListeners(listeners);
        return () => {
            stateManager.removeEntityEvictListeners(listeners);
        }
    }, [stateManager]);
    
    return ...;
});
```

### 3. Examples of practical applications

Define a simple state "selectedBookId"

```ts
import { createState } from './__generated';
import { BookChangeEvent } from './__generated/triggers';

export const selectedBookIdState = createState<string | undefined>("selectedBookId", undefined, {
    mount: ctx => {
        const listners = {
            "Book": (e: BookChangeEvent) => {
                if (e.changeType === "delete" && e.id === ctx()) {
                    ctx(undefined); // reset this simple state when current book is deleted
                }
            }
        };
        ctx.stateManager.addEntityChangeListeners(listeners);
        return () => {
            ctx.stateManager.removeEntityChangeListeners(listeners);
        };
    }
});
```

Here, we use the effect register/unregister trigger of the simple state. If the object pointed to by the current state is deleted, then the current simple state is automatically set to undefined.

"selectedBookId" is just an id, not a Book object. To convert it to a "selectedBook" object, there are two ways

1. If other pages have very different requirements for the shape of the "selectedBook" object, you can use "useObject" in other pages, for example
  ```ts
  import { FC, memo } from 'react';
  import { useStateValue } from 'graphql-state';
  import { selectedBookIdState } from './State'; 
  import { book$$, author$$ } from './__generated';

  export const MyComponent: FC = memo(() => {
      
      const selectedBookId = useStateValue(selectedBookIdState);
      
      const { data: selectedBook, loading } = useObject(
          
          book$$
          .authors(
              author$$
          ),
          
          selectedBookId,
          
          {
              asyncStyle: "async-object",

              // Important, otherwise the second parameter of useObject must not be undefined
              objectStyle: "optional" 
          }
      );

      return ...;
  });
  ```
  > Note
  >
  > It is very important to let objectStyle be "optional", otherwise the second parameter of useObject is not allowed to be undefined, which will cause compilation error
    
2. If other pages have the same requirements for the shape of the selectedBook object, you can wrap the selectedBook as a simple state. For example
  ```
  import { book$$, author$$ } from './__generated';
  import { ModelType } from 'graphql-ts-client';
   
  const SELECTED_BOOK_SHAPE = book$$
      .authors(
      author$$
      )
  ;

  export const selectedBookState = createAsyncState<
      ModelType<typeof SELECTED_BOOK_SHAPE>
  >("selectedBook", ctx => {
      return ctx.object(
          
          SELECTED_BOOK_SHAPE,
          
          ctx(selectedBookIdState),
          
          {
              // Important, otherwise the second parameter of "ctx.object" cannot be undefined
              objectStyle: "optional"
          }
      );
  });
  ```
  > Note
  >
  > It is very important to let objectStyle be "optional", otherwise the second parameter of "ctx.object" is not allowed to be undefined, which will cause compilation error
  
----------
[< Previous: Mutation](./mutation/README.md) | [Back to parent: Graph state](./README.md)
