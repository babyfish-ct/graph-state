# [graphql-state](https://github.com/babyfish-ct/graphql-state)/[Documentation](../README.md)/[Graph state](./README.md)/Trigger

The built-in cache database supports triggers and supports the following two types of events
- EntityChangeEvent: Data is changed
- EntityEvictEvent: Data is evicted form local cache

## 1. EntityChangeEvent

"EntityChangeEvent" represents the event that the entity object is modified

### 1.1. Event type definition

1. Definition of general events for any object type
  ```ts
  export interface EntityChangeEvent {
      readonly eventType: "change";
      readonly typeName: string;
      readonly id: any;
      readonly changedType: "insert" | "update" | "delete";
      readonly changedKeys: ReadonlyArray<EntityKey>;
      has(changedKey: EntityKey): boolean;
      oldValue(changedKey: EntityKey): any;
      newValue(changedKey: EntityKey): any;
  }

  export type EntityKey = string | {
      readonly name: string,
      readonly variables: any
  };
  ```
  
  - eventType: always be "change", used to distinguish between "EntityChangeEvent" and "EntityEvictEvent"
  - typeName: The type of the object that triggered the event. If the object has an inheritance relationship, take the name of the actual type at runtime
  - id: the id of the object
  - changedType: three choices
    - "insert": Indicates that the object is inserted into the cache. At this time, the "newValue" function can be called, but "oldValue" will throw an exception
    - "update": Indicates that the object in the cache has been updated. At this time, both "oldValue" and "newValue" functions can be called
    -"delete": Indicates that the object in the cache is deleted. At this time, the "oldValue" function can be called, but "newValue" will throw an exception
  - has: Determine whether a field has been changed, only the changed field can be used as the parameter of the "oldValue" and "newValue" functions, otherwise it will cause an exception
    Parameters:
    - changedKey: field, divided into two cases
      - Unparameterized field: just a string
      - Parameterized field: pass an object with 2 fields
        - name: the name of the field
        - variables: the variables of the field
  - oldValue: Get the old value of a field before it is modified. If changedType is "insert" or the same parameter will cause the "has" function to return false, an exception will be raised
    Parameters:
    - changedKey: field, divided into two cases
      - Unparameterized field: just a string
      - Parameterized field: pass an object with 2 fields
        - name: the name of the field
        - variables: the variables of the field
  - newValue: Get the new value of a field after it is modified. If the changedType is "delete" or the same parameter will cause the "has" function to return false, an exception will be raised
    Parameters:
    - changedKey: field, divided into two cases
      - Unparameterized field: just a string
      - Parameterized field: pass an object with 2 fields
        - name: the name of the field
        - variables: the variables of the field
       
2. Specific event definitions for specific object types (generated by the code generator, here with [example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts](https://github.com/babyfish-ct/graphql-state/blob/master/example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts) as an example)

  ```ts
  import {ImplementationType} from '../CommonTypes';
  import {BookArgs, BookFlatType} from '../fetchers/BookFetcher';

  export interface BookChangeEvent {

      readonly eventType: "change";

      readonly typeName: ImplementationType<"Book">;

      readonly id: string;

      readonly changedType: "insert" | "update" | "delete";

      readonly changedKeys: ReadonlyArray<BookEntityKey<any>>;

      has(changedKey: BookEntityKey<any>): boolean;

      oldValue<TFieldName extends BookEntityFields>(
          key: BookEntityKey<TFieldName>
      ): BookFlatType[TFieldName] | undefined;

      newValue<TFieldName extends BookEntityFields>(
          key: BookEntityKey<TFieldName>
      ): BookFlatType[TFieldName] | undefined;
  }

  export type BookEntityKey<TFieldName extends BookEntityFields> = 
      TFieldName extends "authors" ? 
      { readonly name: "authors"; readonly variables: BookArgs } : 
      TFieldName
  ;

  export type BookEntityFields = 
      "name" | 
      "store" | 
      "authors"
  ;
  ```
It has the same function as the EntityChangeEvent type, except that the internal field type is more precise. There is no difference in the meaning of its fields, so I won’t repeat them here.

### 1.2 Add EntityChangeEvent

1. Based on common event types

```ts
import { FC, memo } from 'react';
import { EntityChangeEvent } from 'graphql-state';
import { useTypedStateManager } from './__generated';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const listener = (e: EntityChangeEvent) => {
            if (e.typeName === "BookStore") {
                // TODO
            } else if (e.typeName === "Book") {
                // TODO
            } else if (e.typeName === "Author") {
                // TODO:
            }
        };
        stateManager.addEntityChangeListener(listener);
        return () => {
            stateManager.removeEntityChangeListener(listener);
        }
    }, [stateManager]);
    
    return ...;
});
```

2. Based on dedicated event type

```ts
import { FC, memo } from 'react';
import { useTypedStateManager } from './__generated';
import { BookStoreChangeEvent, BookChangeEvent, AuthorChangeEvent } from './__generated/triggers';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const listeners = {
            "BookStore": (e: BookStoreChangeEvent) => {
                // TODO
            },
            "Book": (e: BookChangeEvent) => {
                // TODO
            },
            "Author": (e: AuthorChangeEvent) => {
                // TODO
            }
        };
        stateManager.addEntityChangeListeners(listeners);
        return () => {
            stateManager.removeEntityChangeListeners(listeners);
        }
    }, [stateManager]);
    
    return ...;
});
```

## 2. EntityEvictEvent

"EntityChangeEvent" indicates that the entity object is evicted from the cache

> Note
>
> 1. Data being evicted from the cache and data being deleted are two completely different concepts
> 2. For application developers, "EntityEvictEvent" is not as useful as "EntityChangeEvent". If you are not interested, you can skip this chapter and look directly at the application example

### 2.1 Event type definition

1. Definition of general events for any object type
  ```ts
  export interface EntityEvictEvent {
      readonly eventType: "evict";
      readonly typeName: string;
      readonly id: any;
      readonly causedByGC: boolean;
      readonly evictedType: "row" | "fields";
      readonly evictedKeys: ReadonlyArray<EntityKey>;
      has(evictedKey: EntityKey): boolean;
      evictedValue(evictedKey: EntityKey): any;
  }

  export type EntityKey = string | {
      readonly name: string,
      readonly variables: any
  };
  ```
  - eventType: always be "evict", used to distinguish between "EntityEvictEvent" and "EntityChangeEvent"
  - typeName: The type of the object that triggered the event. If the object has an inheritance relationship, take the name of the actual type at runtime
  - id: the id of the object
  - **causedByGC**: Whether triggered by garbage collection
    - true: The current event is caused by garbage collection
    - false: The current event is caused by mutation
    > Note
    >
    > causedByGC is true means indicate that garbage collection caused current event. Only the data discarded by all queries will be garbage collected, so the current event will not cause any queries to be automatically refreshed
  - id: the id of the object
  - evictType: Tow choices
    - "row": Indicates that the entire object is evicted from the cache
    - "fields": Indicates that some fields of the object are evicted from the cache
  - "has": Determine that a field is evicted from the cache, only the evicted field can be used as the parameter of the "evictedValue" function, otherwise it will cause an exception
    Parameters:
    - evictedKey: field, divided into two cases
      -Unparmeterized field: just a string
      -Parameterized field: pass an object with 2 fields
        -name: the name of the field
        -variables: the variables of the field
  -evictedValue: Get the old value of a field before it is evicted from the cache. If the same parameter will cause the "has" function to return false, an exception will be raised
    Parameters:
    - evictedKey: field, divided into two cases
      -Unparmeterized field: just a string
      -Parameterized field: pass an object with 2 fields
        -name: the name of the field
        -variables: the variables of the field

2. Specific event definitions for specific object types (generated by the code generator, here with [example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts](https://github.com/babyfish-ct/graphql-state/blob/master/example/client/src/graph/__generated_graphql_schema__/triggers/BookChangeEvent.ts) as an example)

  ```ts
  import {ImplementationType} from '../CommonTypes';
  import {BookArgs, BookFlatType} from '../fetchers/BookFetcher';


  export interface BookEvictEvent {

      readonly eventType: "evict";

      readonly typeName: ImplementationType<"Book">;

      readonly id: string;

      readonly causedByGC: boolean;

      readonly evictedType: "row" | "fields";

      readonly evictedKeys: ReadonlyArray<BookEntityKey<any>>;

      has(evictedKey: BookEntityKey<any>): boolean;

      evictedValue<TFieldName extends BookEntityFields>(
          key: BookEntityKey<TFieldName>
      ): BookFlatType[TFieldName] | undefined;
  }

  export type BookEntityKey<TFieldName extends BookEntityFields> = 
      TFieldName extends "authors" ? 
      { readonly name: "authors"; readonly variables: BookArgs } : 
      TFieldName
  ;

  export type BookEntityFields = 
      "name" | 
      "store" | 
      "authors"
  ;
  ```
和EntityChangeEvent类型的作用一样，只是这个类型的类型更精确而已。其字段的含义也并无差异，此处不在赘述。

### 1.2 添加对象从缓存中被清理事件

1. 基于通用事件类型

```ts
import { FC, memo } from 'react';
import { EntityEvictEvent } from 'graphql-state';
import { useTypedStateManager } from './__generated';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const onEvict = (e: EntityEvictEvent) => {
            if (e.typeName === "BookStore") {
                // TODO
            } else if (e.typeName === "Book") {
                // TODO
            } else if (e.typeName === "Author") {
                // TODO:
            }
        };
        stateManager.addEntityEvictListener(onChange);
        return () => {
            stateManager.removeEntityEvictListener(onChange);
        }
    }, [stateManager]);
    
    return ...;
});
```

2. 基于专用事件类型

```ts
import { FC, memo } from 'react';
import { useTypedStateManager } from './__generated';
import { BookStoreEvictEvent, BookEvictEvent, AuthorEvictEvent } from './__generated/triggers';

export const MyComponent: FC = memo(() => {
    const stateManager = useTypedStateManager();
    useEffect(() => {
        const listeners = {
            "BookStore": (e: BookStoreEvictEvent) => {
                // TODO
            },
            "Book": (e: BookEvictEvent) => {
                // TODO
            },
            "Author": (e: AuthorEvictEvent) => {
                // TODO
            }
        };
        stateManager.addEntityEvictListeners(listeners);
        return () => {
            stateManager.removeEntityEvictListeners(listeners);
        }
    }, [stateManager]);
    
    return ...;
});
```

### 3. 实际应用举例

我们尝试定义个简单状态selectedBookId

```ts
import { createState } from './__generated';
import { BookChangeEvent } from './__generated/triggers';

export const selectedBookIdState = createState<string | undefined>("selectedBookId", undefined, {
    mount: ctx => {
        const listners = {
            "Book": (e: BookChangeEvent) => {
                if (e.changeType === "delete" && e.id === ctx()) {
                    ctx(undefined); // reset this simple state when current book is deleted
                }
            }
        };
        ctx.stateManager.addEntityChangeListeners(listeners);
        return () => {
            ctx.stateManager.removeEntityChangeListeners(listeners);
        };
    }
});
```

这里，我们使用简单状态的effect注册/注销触发器，如果当前状态所指的对象从缓存中被删除，那么将简单状态设置为undefined。

selectedBookId只是一个id，而非Book对象，要将之转换为selectedBook对象, 有两种方法

1. 如果其他页面对selectedBook对象的形状要求差别很大，可以在其他页面中使用useObject，例如
  ```ts
  import { FC, memo } from 'react';
  import { useStateValue } from 'graphql-state';
  import { selectedBookIdState } from './State'; 
  import { book$$, author$$ } from './__generated';

  export const MyComponent: FC = memo(() => {
      
      const selectedBookId = useStateValue(selectedBookIdState);
      
      const { data: selectedBook, loading } = useObject(
          
          book$$
          .authors(
              author$$
          ),
          
          selectedBookId,
          
          {
              asyncStyle: "async-object",

              objectStyle: "optional" //重要，否则useObject的第二个参数不得为undefined
          }
      );

      return ...;
  });
  ```
  > 注意
  > 
  > 代码中objectStyle为"optional"很重要，否则useObject的第二个参数不允许为undefined，将会导致编译错误
    
2. 如果其他页面对selectedBook对象的形状要求差别不大，可以selectedBook包装为一个简单对象，方便各页面复用，例如
  ```
  import { book$$, author$$ } from './__generated';
  import { ModelType } from 'graphql-ts-client';
   
  const SELECTED_BOOK_SHAPE = book$$
      .authors(
      author$$
      )
  ;

  export const selectedBookState = createAsyncState<
      ModelType<typeof SELECTED_BOOK_SHAPE>
  >("selectedBook", ctx => {
      return ctx.object(
          ctx(selectedBookIdState),
          {
              objectStyle: "optional" //重要，否则ctx.object首个参数不得为undefined
          }
      );
  });
  ```
  > 注意
  > 
  > 代码中objectStyle为"optional"很重要，否则ctx.object的第一个参数不允许为undefined，将会导致编译错误
  
----------
[< Previous: 变更](./mutation/README.md) | [Back to parent: 图状态](./README.md)
