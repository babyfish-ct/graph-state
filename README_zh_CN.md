# 一个新的React管理框架

**语言: [English](/) | 中文**

## 系统功能

![image](./architecture_zh_CN.png "系统功能")

### 1. 简单状态
一套看起来非常类似于recoil的状态管理，用于管理业务对象模型以外的零散数据，可以方便地和图状态配合。

### 2. 图状态
本框架的核心价值，和apollo-client/以及relay类似的复杂状态管理，但智能性方面有重大提升。用内置的缓存数据库替代简单的normalize-cache，支持智能的更新操作，让开发变得极简，是我创建此框架的动机。

图状态管理支持两个核心功能
#### 2.1. 智能更新

在使用GraphQL客户端时，开发者面临的最大痛苦是需要需要在变更操作后决定是更新本地缓存还是重新查询。如果选择修改本地缓存，将面临繁重的工作量；如果选择重新查询，不仅会接受性能缺陷，而且确定哪些查询需要重新获取也非易事。

这个框架内置的缓存数据库是高度智能的。你只需要简单地用服务器返回信息去更新它，它会先尝试找出所有其他可能受影响的相关对象，争取直接更新本地缓存，修改新旧数据之间的关系；如果这种尝试不可行，它会自动升级为重新查询行为，并自动确定需要重新获取哪些查询。

![image](./smart-mutation_zh_CN.png "智能更新")

无论框架是选择更好的策略来修改本地数据(A)还是糟糕的重新查询策略(B)。它们都是自动化的，不需要您的干预。

然而，如果你愿意的话，你也可以参与这个抉择进行优化干预。您可以使用简单的API来帮助它优化，增加情况(A)的发生概率并降低情况(B)的发生概率。

#### 2.2. 双向关联管理

参考这样一个例子

- BookStore具备一个books关联属性，一个指向Book的one-to-many关联
- Book具备一个store属性，一个指向BookSotre的many-to-one关联

在业务层上讲，BookStore.books和Book.store其实是同一个关系因视角不不同而展现出的两面，因此，graphql-state允许你把这样的两个关系绑定为双向关联。一旦你完成了这种绑定，你就可以得到如下GIF动画所示的效果

![image](./bidirectional-association.gif "双向关联")

在这个例子中，你执行的修改行为是
```
MANNING.books.add(LearningGraphQL);
```
与此同事，graphql-state会为你执行两个自动更新
```
O'REILLY.books.remove(LearningGraphQL);
LearningGraphQL.store = MANNING;
```

### 3. HTTP优化

当缓存数据无法完成用户期望时，框架不得不想服务端发出HTTP查询请求。但是, graphql-state会充分优化，尽可能降低HTTP请求的数量，比如合并碎片化的小请求，重用查询范围更大的现有请求。


## 文档

[文档](./doc/README_zh_CN.md)

## 其它

这是一个新诞生的框架，为了让它越来越完整，未来会实现的功能如下

### 未来
#### 短期目标

2. 支持级联删除，针对非空的many-to-one关联而言几乎是唯一的选择
3. 预先加载查询
4. 提供RESTNetwork接口，基于REST服务模拟GraphQL服务，这对服务端的遗留项目很有用。

#### 长远目标
1. 事务、保存点、撤销/重做 
2. 支持数据可视化的Chrome插件，以方便调试。


### 变更列表
|版本|描述|graphql-ts-client所需版本|
|-------|-----------|
|0.0.0  |首个版本|>=3.0.4|
|0.0.1  |为内置的缓存数据库添加垃圾回收器|>=3.0.7|
|0.0.2  |支持分页查询API：usePaginationQuery|>=3.0.8|
