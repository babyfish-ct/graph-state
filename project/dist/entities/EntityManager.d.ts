import { EntityChangeEvent } from "..";
import { SchemaMetadata } from "../meta/impl/SchemaMetadata";
import { StateManagerImpl } from "../state/impl/StateManagerImpl";
import { BatchEntityRequest } from "./BatchEntityRequest";
import { ModificationContext } from "./ModificationContext";
import { QueryArgs, QueryResult } from "./QueryResult";
import { Record } from "./Record";
import { RecordManager } from "./RecordManager";
import { RecordRef } from "./RecordRef";
import { RuntimeShape } from "./RuntimeShape";
export declare class EntityManager {
    readonly stateManager: StateManagerImpl<any>;
    readonly schema: SchemaMetadata;
    private recordManagerMap;
    private queryResultMap;
    readonly batchEntityRequest: BatchEntityRequest;
    private _entityChangeListenerMap;
    private _ctx?;
    constructor(stateManager: StateManagerImpl<any>, schema: SchemaMetadata);
    recordManager(typeName: string): RecordManager;
    findRefById(typeName: string, id: any): RecordRef | undefined;
    get modificationContext(): ModificationContext;
    modify<T>(action: () => T): T;
    save(shape: RuntimeShape, objOrArray: object | readonly object[]): void;
    delete(typeName: string, idOrArray: any): void;
    saveId(typeName: string, id: any): Record;
    loadByIds(ids: any[], shape: RuntimeShape): Promise<any[]>;
    retain(queryArgs: QueryArgs): QueryResult;
    release(queryArgs: QueryArgs): void;
    addListener(typeName: string | undefined, listener: (e: EntityChangeEvent) => void): void;
    removeListener(typeName: string | undefined, listener: (e: EntityChangeEvent) => void): void;
    private linkToQuery;
    private publishEntityChangeEvent;
    private queryKeyOf;
}
